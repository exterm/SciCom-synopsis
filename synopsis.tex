\documentclass[a4paper, 12pt]{article}

\usepackage[margin=2cm,top=2.7cm,bottom=2.7cm]{geometry}
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage{lastpage}
\usepackage[bookmarks, hidelinks]{hyperref}
\usepackage{fancyhdr}
\usepackage{setspace}
\usepackage{comment}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{enumitem}

\setlength{\parindent}{0pt}
\setlist[description]{itemindent=-30pt, leftmargin=50pt, itemsep=.5em}

\pagestyle{fancy}
 
\lhead{Scientific Computing}
\chead{Zusammenfassung}
\rhead{WS 2011/2012}

\lfoot{Philip Müller, inf9293}
\cfoot[Seite \thepage\ von \pageref{LastPage}]{Seite \thepage\ von \pageref{LastPage}}
\rfoot{\today}
\renewcommand{\footrulewidth}{.5pt}

\begin{document}

\tableofcontents
\pagebreak



\part{Grundlagen}



\section{Definition}
Scientific Computing ist
\begin{itemize}
  \item numerische Simulation
  \item Lösung numerischer Probleme aus verschiedenen wissenschaftlichen Disziplinen
\end{itemize}



\section{Numerik-Grundlagen}


\subsection{Reelle Zahlen}

\subsubsection*{Repräsentation}
\begin{itemize}
  \item Im Rechner üblicherweise Teilmenge der reellen Zahlen benutzt: Gleitkommazahlen
  \item Gleitkomma-Repräsentation einer reellen Zahl verlustbehaftet, ``beschnittene Zahl''
\end{itemize}
\begin{description}
  \item[Darstellung] durch
    \begin{itemize}
      \item Vorzeichen
      \item Basis
      \item Mantisse
      \item Exponent
    \end{itemize}
  \item[Rundungsfehler] beim Repräsentieren
    \begin{itemize}
      \item \(|x-fl(x)|/|x| \le \frac{1}{2} \epsilon_M\)
      \item \(\epsilon_M = \beta^{1-t}\) gibt Abstand zwischen 1 und der nächsten Gleitkommazahl größer 1 an
      \item \(\epsilon_M\) in MATLAB durch das Kommando \texttt{eps} bestimmbar
    \end{itemize}
\end{description}

\subsubsection*{Eingeschränkte Gesetze}
\begin{itemize}
  \item Kommutativität gilt
  \item die 0 ist nicht eindeutig
  \item Assoziativität und Distributivität gelten nicht!\\
    z.B. bei Rechnungen die an die Ränder des Zahlenbereichs gehen
\end{itemize}

\subsubsection*{Auslöschen signifikanter Stellen}
Wenn man zwei Gleitkommazahlen addiert, die ähnliche Absolutwerte haben, aber gegenätzliches Vorzeichen, wird das Ergebnis ungenau.

Beispiel:
\begin{align*}
x = 1e-15\\
\Rightarrow \frac{((1+x)-1)}{x} = 1.1102
\end{align*}
11\% Fehler!


\subsection{Komplexe Zahlen}
--- Nur simple Wiederholung und MATLAB ---


\subsection{Matrizen}
--- Nur simple Wiederholung und MATLAB ---


\subsection{Vektoren}
--- Nur simple Wiederholung und MATLAB ---




\part{Methoden}



\section{Nichtlineare Gleichungen}


\subsection{Bisektionsverfahren}

\subsubsection*{Verfahren}
\begin{itemize}
  \item sei \(f\) stetige Funktion über \([a,b]\), \(f(a)\times f(b)<0\)
  \item Also mindestens eine Nullstelle in \([a,b]\)
  \item Bisektion geht von genau einer Nullstelle aus
  \item Algorithmus:
    \begin{enumerate}
      \item teile das Interval in zwei gleich große Teilintervalle
      \item fahre mit dem Interval, dessen Grenzen funktionswerte mit verschiedenen Vorzeichen haben, fort
      \item goto 1
    \end{enumerate}
\end{itemize}
\begin{itemize}
  \renewcommand{\labelitemi}{\(-\)}%
  \item Fehler nicht monoton fallend, die Näherung kann mit weiteren Schritten auch schlechter werden
  \item unabhängig von Verlauf der Funktion, könnte deshalb effizienter sein (Beispiel Gerade)
\end{itemize}
\begin{itemize}
  \renewcommand{\labelitemi}{+}%
  \item einfache Implementierung, betrachtet Funktion als ``Black Box''
\end{itemize}

\subsubsection*{Abbruch}
Erfolgt bei Erreichung gewünschter Toleranz.\\
Anzahl erforderlicher Schritte:
\[k_{min} > log_2(\frac{b-a}{\epsilon})-1\]

\subsubsection*{Konvergenz}
Die Bisektion konvergiert immer.


\subsection{Newton-Verfahren}

\subsubsection*{Verfahren}
\begin{itemize}
  \item Verwendung der Ableitung der Funktion
  \item Algorithmus:
    \begin{enumerate}
      \item Starte mit einem beliebigen Punkt \(x_0\) (\(k=0\))
      \item Bestimme die Tangente \(T\) im Punkt \(x_k\)
      \item \(x_{k+1} = T^{-1}(0)\)
      \item \(k=k+1\), goto 2
    \end{enumerate}
\end{itemize}

\subsubsection*{Abbruch}
Mögliche Kriterien:
\begin{itemize}
  \item nach willkürlich festgelegter Iterationszahl --- keine Aussage über Fehler machbar
  \item Abschätzen des Fehlers durch Differenz zweier aufeinanderfolgender Näherungswerte --- funktioniert ``gut'' bei einfachen Nullstellen
  \item \emph{Residuum} (Funktionswert am Näherungswert) unterschreitet Toleranz --- problematisch, da von Steigung der Funktion in der Nähe der Nullstelle abhängig
\end{itemize}

\subsubsection*{Konvergenz}
\begin{itemize}
  \item konvergiert für lineare Funktionen in einem Schritt
  \item allgemein konvergiert das Verfahren nicht immer, der Startpunkt muss \emph{nahe genug} an der Nullstelle sein --- das ist abhängig von der Funktion
  \item Idee: Mittels einiger Bisektionsschritte nahe genug an die Nullstelle kommen, dann mit Newton verfeinern
\end{itemize}


\subsection{Fixpunkt-Iteration}

\subsubsection*{Verfahren}
\begin{itemize}
  \item Methode zum Finden von Fixpunkten einer Funktion \(f\)
  \item Algorithmus:
    \begin{enumerate}
      \item \(f\) wird auf einen Startwert angewendet
      \item \(f\) wird auf das Ergebnis angewendet
      \item goto 2
    \end{enumerate}
  \item Das Newton-Verfahren lässt sich als Fixpunkt-Iteration über die Funktion
    \[\phi(x) = x-\frac{f(x)}{f'(x)}\]
    darstellen
\end{itemize}

\subsubsection*{Abbruch}
Wenn die absolute Differenz zweier aufeinanderfolgender Näherungen unter einem Toleranzwert liegt. Die Abschätzung des Fehlers nach dieser Methode ist umso genauer, je näher \(\phi'(\alpha)\) an 1 liegt.

\subsubsection*{Konvergenz}
Schwierig zu bewerten. Sicher konvergiert die Fixpunkt-Iteration aber, wenn diese Bedingungen erfüllt sind:
\begin{itemize}
  \item Betrachte Funktion \(\phi\) auf einem Intervall \([a,b]\)
  \item \(\phi\) ist in \([a,b]\) differenzierbar
  \item \(\forall x \in [a,b]: \phi(x) \in [a,b]\)
  \item \(\forall x \in [a,b]: |\phi'(x)|<1\)\\
    TODO ist das so? Mysteriöses K...
\end{itemize}
\(\phi\) besitzt dann genau einen Fixpunkt im Intervall \([a,b]\) und die Fixpunkt-Iteration konvergiert unabhängig von der Wahl des Startwerts (der allerdings im Intervall liegen muss).


\subsection{Algebraische Polynome}
--- hier Text einfügen --- TODO


\subsection{Newton-Horner-Verfahren}
--- hier Text einfügen --- TODO



\section{Numerisches Differenzieren}


\subsection{Problem}
Habe Funktionswerte an mehreren Stellen aber keine Funktionsdefinition, möchte Änderungsrate (Ableitung) approximieren.


\subsection{Taylor-Entwicklung}
--- hier Text einfügen ---



\section{Numerisches Integrieren}


\subsection{Problem}
--- hier Text einfügen ---


\subsection{Mittelpunktformel}
--- hier Text einfügen ---


\subsection{Trapezformel}
--- hier Text einfügen ---


\subsection{Simpson-Formel}
--- hier Text einfügen ---



\section{Lineare Systeme}


\subsection{LU-Faktorisierung}
--- hier Text einfügen ---


\subsection{Gauß-Faktorisierung}
--- hier Text einfügen ---


\subsection{Pivoting}
--- hier Text einfügen ---



\section{Gewöhnliche Differentialgleichungen}


\subsection{Allgemeines}
--- hier Text einfügen ---


\subsection{Euler-Verfahren}
--- hier Text einfügen ---


\subsection{Verfahren höherer Ordnung}
--- hier Text einfügen ---



\section{Interpolation}


\subsection{Langrange-Interpolation}
--- hier Text einfügen ---


\subsection{Runge-Interpolation}
--- hier Text einfügen ---


\subsection{Chebyshev-Interpolation}
--- hier Text einfügen ---


\subsection{Stückweise Lineare Interpolation}
--- hier Text einfügen ---


\subsection{Spline-Funktionen}
--- hier Text einfügen ---



\section{Eigenwerte und Eigenvektoren}


\subsection{Potenzverfahren}
--- hier Text einfügen ---


\subsection{QR-Zerlegung}
--- hier Text einfügen ---




\part{Parallelisierung}



\section{IPython}



\section{Leistungsmaße}


\subsection{Laufzeit}
--- hier Text einfügen ---


\subsection{Speedup}
--- hier Text einfügen ---



\section{Zerlegungsmethoden}


\subsection{Allgemeines}
--- hier Text einfügen ---


\subsection{Funktionale Zerlegung}
--- hier Text einfügen ---


\subsection{Datenzerlegung}
--- hier Text einfügen ---


\subsection{Funktions- und Datenzerlegung}
--- hier Text einfügen ---



\section{Beispiele}


\subsection{Parallele LU-Faktorisierung}
--- hier Text einfügen ---






%%%%%%%%%%



\section{Bli}


\subsection{bla}

\subsubsection*{blubb}

\begin{itemize}
  \item allgemeine Eigenschaften
\end{itemize}
\begin{itemize}
  \renewcommand{\labelitemi}{\(-\)}%
  \item Nachteile
\end{itemize}
\begin{itemize}
  \renewcommand{\labelitemi}{+}%
  \item Vorteile
\end{itemize}



\end{document}
